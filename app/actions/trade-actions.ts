// app/actions/trade-actions.ts
"use server";

import { prisma } from "@/lib/prisma";
import { z } from "zod";
import { revalidatePath } from "next/cache";
// Corrected import path for Prisma types if direct import of 'Prisma' fails
// This import path points to the type definitions generated by Prisma.
import {
  Trade as PrismaTradeModel, // Alias to avoid naming conflict with our 'Trade' type
  Prisma, // This import usually works for the Prisma namespace with types
} from '@prisma/client';


// --- Define a type for your Trade model ---
// Use the aliased type from the Prisma client
export type Trade = PrismaTradeModel; // Your Trade type is directly from Prisma's generated type

// --- Zod Schemas for Input Validation ---
const baseTradeSchema = z.object({
  sno: z.coerce.number().int().positive("S.NO must be a positive integer"),
  date: z.string().min(1, "Date is required"),
  strike: z.string().min(1, "Strike is required"),
  buyingPrice: z.coerce.number().nonnegative("Buying Price must be a non-negative number"),
  exitPrice: z.coerce.number().nonnegative("Exit Price must be a non-negative number"),
  target: z.string().nullable().optional(),
  high: z.string().nullable().optional(),
  profitLoss: z.string().nullable().optional(),
  totalPoints: z.coerce.number().nullable().optional(),
});

const createTradeSchema = baseTradeSchema;

const updateTradeSchema = baseTradeSchema.partial().extend({
  id: z.string().min(1, "ID is required for update"),
});

// --- Standardized Server Action Response Type ---
type ActionResponse<T> =
  | { success: true; data: T }
  | { success: false; error: string; errors?: Record<string, string[] | undefined> };

// Helper function to process FormData for null/empty strings
function processFormDataForNulls(rawFormData: Record<string, FormDataEntryValue>): Record<string, FormDataEntryValue | null> {
  const processed: Record<string, FormDataEntryValue | null> = {};
  for (const [key, value] of Object.entries(rawFormData)) {
    processed[key] = value === '' ? null : value;
  }
  return processed;
}

// --- Server Actions ---

export async function createTrade(formData: FormData): Promise<ActionResponse<Trade>> {
  try {
    const rawFormData = Object.fromEntries(formData.entries());
    const processedFormData = processFormDataForNulls(rawFormData);

    const validatedData = createTradeSchema.safeParse(processedFormData);

    if (!validatedData.success) {
      const fieldErrors = validatedData.error.flatten().fieldErrors;
      const errorMessage = Object.entries(fieldErrors)
        .map(([field, messages]) => `${field}: ${messages?.join(", ")}`)
        .join("; ");
      return { success: false, error: `Validation failed: ${errorMessage}`, errors: fieldErrors };
    }

    // Explicitly type the data object to match Prisma's expected input for create
    const newTradeData: Prisma.TradeCreateInput = { // Use Prisma.TradeCreateInput here
      sno: validatedData.data.sno,
      date: validatedData.data.date,
      strike: validatedData.data.strike,
      buyingPrice: validatedData.data.buyingPrice,
      exitPrice: validatedData.data.exitPrice,
      target: validatedData.data.target || null,
      high: validatedData.data.high || null,
      profitLoss: validatedData.data.profitLoss || null,
      totalPoints: validatedData.data.totalPoints || null,
    };

    const newTrade = await prisma.trade.create({
      data: newTradeData,
    });

    revalidatePath("/dashboard/market");
    revalidatePath("/");
    return { success: true, data: newTrade };
  } catch (error) {
    console.error("Error creating trade:", error);
    if (error instanceof Error) {
      return { success: false, error: `Failed to create trade: ${error.message}` };
    }
    return { success: false, error: "Failed to create trade due to an unknown error." };
  }
}

export async function getTrades(): Promise<ActionResponse<Trade[]>> {
  try {
    const trades = await prisma.trade.findMany({
      orderBy: { createdAt: 'asc' },
    });
    return { success: true, data: trades };
  } catch (error) {
    console.error("Error fetching trades:", error);
    if (error instanceof Error) {
      return { success: false, error: `Failed to fetch trades: ${error.message}` };
    }
    return { success: false, error: "Failed to fetch trades due to an unknown error." };
  }
}

export async function updateTrade(formData: FormData): Promise<ActionResponse<Trade>> {
  try {
    const rawFormData = Object.fromEntries(formData.entries());
    const processedFormData = processFormDataForNulls(rawFormData);

    const validatedData = updateTradeSchema.safeParse(processedFormData);

    if (!validatedData.success) {
      const fieldErrors = validatedData.error.flatten().fieldErrors;
      const errorMessage = Object.entries(fieldErrors)
        .map(([field, messages]) => `${field}: ${messages?.join(", ")}`)
        .join("; ");
      return { success: false, error: `Validation failed: ${errorMessage}`, errors: fieldErrors };
    }

    const { id, ...updatePayload } = validatedData.data;

    if (!id) {
      return { success: false, error: "Trade ID is missing for update." };
    }

    // Explicitly type the update payload for Prisma
    const updateTradeData: Prisma.TradeUpdateInput = { // Use Prisma.TradeUpdateInput here
      sno: updatePayload.sno,
      date: updatePayload.date,
      strike: updatePayload.strike,
      buyingPrice: updatePayload.buyingPrice,
      exitPrice: updatePayload.exitPrice,
      target: updatePayload.target || null,
      high: updatePayload.high || null,
      profitLoss: updatePayload.profitLoss || null,
      totalPoints: updatePayload.totalPoints || null,
    };

    const updatedTrade = await prisma.trade.update({
      where: { id: id },
      data: updateTradeData,
    });

    revalidatePath("/dashboard/market");
    revalidatePath("/");
    return { success: true, data: updatedTrade };
  } catch (error) {
    console.error("Error updating trade:", error);
    if (error instanceof Error) {
      return { success: false, error: `Failed to update trade: ${error.message}` };
    }
    return { success: false, error: "Failed to update trade due to an unknown error." };
  }
}

export async function deleteTrade(id: string): Promise<ActionResponse<null>> {
  try {
    await prisma.trade.delete({
      where: { id },
    });
    revalidatePath("/dashboard/market");
    revalidatePath("/");
    return { success: true, data: null };
  } catch (error) {
    console.error("Error deleting trade:", error);
    if (error instanceof Error) {
      return { success: false, error: `Failed to delete trade: ${error.message}` };
    }
    return { success: false, error: "Failed to delete trade due to an unknown error." };
  }
}

export async function deleteAllTrades(): Promise<ActionResponse<null>> {
  try {
    await prisma.trade.deleteMany({});
    revalidatePath("/dashboard/market");
    revalidatePath("/");
    return { success: true, data: null };
  } catch (error) {
    console.error("Error deleting all trades:", error);
    if (error instanceof Error) {
      return { success: false, error: `Failed to delete all trades: ${error.message}` };
    }
    return { success: false, error: "Failed to delete all trades due to an unknown error." };
  }
}